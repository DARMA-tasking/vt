###############################################################################
############## Warning this is a generated file---do not modify ###############
###############################################################################

name: PR tests (clang-8, alpine, mpich)

trigger:
  branches:
    include:
      - develop
      - 1.0.0*

pr:
  branches:
   include:
     - '*'


resources:
- repo: self

variables:
  System.Debug: true
  tag: '$(Build.BuildId)'
  REPO: lifflander1/vt
  ARCH: amd64

  COMPILER_TYPE: clang
  COMPILER: clang-8
  BUILD_TYPE: release
  ULIMIT_CORE: 0
  CODE_COVERAGE: 0
  VT_LB: 1
  VT_TRACE: 0
  VT_TRACE_RT: 0
  VT_TRACE_ONLY: 1
  VT_MIMALLOC: 0
  VT_DOCS: 0
  VT_ASAN: 0
  VT_WERROR: 1
  VT_POOL: 1
  VT_EXTENDED_TESTS: 1
  VT_UNITY_BUILD: 1
  VT_FCONTEXT: 0
  VT_USE_OPENMP: 0
  VT_USE_STD_THREAD: 0
  VT_ZOLTAN: 0
  VT_CI_BUILD: 1
  VT_DIAGNOSTICS: 1
  CACHE: "$(Agent.TempDirectory)/cache/"
  cache_name: alpine-clang-8-cache
  build_root: "$(CACHE)/$(ARCH)-alpine-$(COMPILER)-cache/"
  TS: 0
  TS_YEAR: 0
  TS_MONTH: 0
  TS_DAY: 0

stages:
- stage: Build
  displayName: Build image
  jobs:
  - job: Build
    displayName: Build
    pool:
      vmImage: 'ubuntu-18.04'
    timeoutInMinutes: 180
    steps:
      - task: Bash@3
        displayName: Job setup
        inputs:
          targetType: 'inline'
          script: |
            echo setup
      - task: Bash@3
        displayName: Build timestep for caching
        inputs:
          targetType: 'inline'
          script: |
            echo 'string(TIMESTAMP current_date "%H;%M;%S" UTC)' > script
            echo 'execute_process(COMMAND ${CMAKE_COMMAND} -E echo "${current_date}")' >> script
            val=$(cmake -P script)
            echo "##vso[task.setvariable variable=TS]$val"
            echo 'string(TIMESTAMP current_date "%Y" UTC)' > script
            echo 'execute_process(COMMAND ${CMAKE_COMMAND} -E echo "${current_date}")' >> script
            val=$(cmake -P script)
            echo "##vso[task.setvariable variable=TS_YEAR]$val"
            echo 'string(TIMESTAMP current_date "%m" UTC)' > script
            echo 'execute_process(COMMAND ${CMAKE_COMMAND} -E echo "${current_date}")' >> script
            val=$(cmake -P script)
            echo "##vso[task.setvariable variable=TS_MONTH]$val"
            echo 'string(TIMESTAMP current_date "%d" UTC)' > script
            echo 'execute_process(COMMAND ${CMAKE_COMMAND} -E echo "${current_date}")' >> script
            val=$(cmake -P script)
            echo "##vso[task.setvariable variable=TS_DAY]$val"
      - task: Bash@3
        displayName: Output timestamp for caching
        inputs:
          targetType: 'inline'
          script: 'echo "my pipeline variable is $(TS) $(TS_YEAR) $(TS_MONTH) $(TS_DAY)"'
      - task: Cache@2
        displayName: Update cache
        inputs:
          securityNamespace: cache
          key: $(Agent.OS) | "$(cache_name)" | $(TS_YEAR) | $(TS_MONTH) | $(TS_DAY) | $(TS)
          path: '$(build_root)/ccache'
          restoreKeys: |
            $(Agent.OS) | "$(cache_name)" | $(TS_YEAR) | $(TS_MONTH) | $(TS_DAY)
            $(Agent.OS) | "$(cache_name)" | $(TS_YEAR) | $(TS_MONTH)
            $(Agent.OS) | "$(cache_name)" | $(TS_YEAR)
            $(Agent.OS) | "$(cache_name)"
      - task: Bash@3
        displayName: Check for changes in containers
        inputs:
          targetType: 'inline'
          script: |
            val=$(./scripts/check_containers.sh)
            echo "##vso[task.setvariable variable=compose_command]$val"
      - task: DockerCompose@0
        displayName: Pull container
        inputs:
          containerregistrytype: 'Container Registry'
          dockerComposeFile: '**/docker-compose.yml'
          action: 'Run a Docker Compose command'
          dockerComposeCommand: '$(compose_command) alpine-cpp-clean'
      - task: DockerCompose@0
        displayName: Build container
        inputs:
          containerregistrytype: 'Container Registry'
          dockerComposeFile: '**/docker-compose.yml'
          action: 'Run a Docker Compose command'
          dockerComposeCommand: 'run alpine-cpp-clean'
      - task: Bash@3
        displayName: Prepare comment with compilation errors and warnings
        condition: and(succeededOrFailed(), eq(variables['Build.Reason'], 'PullRequest'))
        inputs:
          targetType: 'inline'
          # Maximum length of the comment body is 65536 characters.
          # https://github.community/t/maximum-length-for-the-comment-body-in-issues-and-pr/148867
          #
          # Minus some decorations, comment's title, and additional description gives about 64.5k characters.
          #
          # What this script does? -.
          #                         |
          #                         V
          # * reads warnings and errors from a file,
          # * if there aren't any errors or warnings, returns information about it,
          # * replaces special delimiter with CRLF - %0D%0A (essentially restores new lines),
          # * outputs preprocessed report to a variable for the next task (that puts it as a PR comment).
          script: |
            max_comment_size=64450
            warnings_errors=$(cat $(build_root)/vt/compilation_errors_warnings.out)
            if test -z "$warnings_errors"
            then
            warnings_errors='Compilation - successful'
            fi
            tests_failures=$(< $(build_root)/vt/cmake-output.log sed -n -e '/The following tests FAILED:/,$p')
            if test -z "$tests_failures"
            then
            tests_failures='Testing - passed'
            fi
            val="$warnings_errors"$'\n'$'\n'"$tests_failures"
            if test ${#val} -gt "$max_comment_size"
            then
            val="${val:0:max_comment_size}%0D%0A%0D%0A%0D%0A ==> And there is more. Read pipeline log. <=="
            fi
            delimiter="-=-=-=-"
            new_line="\n"
            comment_body=${val//$delimiter/$new_line}
            quotation_mark="\""
            new_quotation_mark="\\\""
            comment_body=${comment_body//$quotation_mark/$new_quotation_mark}
            echo "##vso[task.setvariable variable=comp_errs_warns;]$comment_body"
      - task: Bash@3
        displayName: Put warnings and errors in PR comment
        condition: and(succeededOrFailed(), and(eq(variables['Build.Reason'], 'PullRequest'), ne(variables['comp_errs_warns'], '')))
        inputs:
          targetType: 'inline'
          script: |
            rm data.json || true
            {
            echo "{"
            echo '  "event_type": "comment-pr",'
            echo '  "client_payload": {'
            echo '    "commit_sha": "'"$(git log --skip=1 -1  --pretty=format:%H)"'",'
            echo '    "comment_title": "$(Build.BuildNumber)",'
            echo '    "comment_content": "$(comp_errs_warns)",'
            echo '    "pr_number": "$(System.PullRequest.PullRequestNumber)"'
            echo "  }"
            echo "}"
            } >> data.json
            curl \
              --request POST \
              --url https://api.github.com/repos/$(Build.Repository.Name)/dispatches \
              --header "Accept: application/vnd.github.everest-preview+json" \
              --header "Authorization: token $GITHUB_PAT" \
              --data "@data.json"
            rm data.json

        env:
          GITHUB_PAT: $(github_pat)
      - task: DockerCompose@0
        displayName: Push container to registry
        condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
        inputs:
          containerregistrytype: 'Container Registry'
          dockerRegistryEndpoint: 'dockerRegistryConnection1'
          dockerComposeFile: '**/docker-compose.yml'
          action: 'Run a Docker Compose command'
          dockerComposeCommand: 'push alpine-cpp-clean'
      - task: Bash@3
        displayName: Create artifacts
        inputs:
          targetType: 'inline'
          script: |
            zip -j $(Agent.TempDirectory)/LastTest.log.gz $(build_root)/vt/Testing/Temporary/LastTest.log
            zip -j $(Agent.TempDirectory)/cmake-output.log.gz $(build_root)/vt/cmake-output.log
      - task: PublishPipelineArtifact@1
        displayName: Upload CMake test output artifact
        inputs:
          targetPath: '$(Agent.TempDirectory)/LastTest.log.gz'
          artifact: 'CMakeLastTestLog'
          publishLocation: 'pipeline'
      - task: PublishPipelineArtifact@1
        displayName: Upload CMake full output artifact
        inputs:
          targetPath: '$(Agent.TempDirectory)/cmake-output.log.gz'
          artifact: 'CMakeOutputLog'
          publishLocation: 'pipeline'
